# 20191010第二次作业

安装完OpenCV后并下载visual Studio配置环境我完成了第一次作业。

## 一、第一个程序：图像显示
### 1、程序分析：
用imread函数载入到新版本的图像存储数据结构Mat类中，然后用imshow函数显示。
### 2、主要函数说明：
### （1）imread函数用于读取文件中的图片到OpenCV中，其格式为：
Mat  imread（const string& filename, intflages=1);
### （2） imshow函数用于在指定的窗口中显示一幅图像，其函数原型为：
void imshow（const string& winname，InputArray mat）；
### 3、运行的效果图如下：
![](./Images/01.png)

## 二、第二个程序：图像腐蚀
腐蚀即用图像中的暗色部分“腐蚀”掉图像中的高亮部分。腐蚀的效果是把图片"变瘦"，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有0和255，所以小区域内有一个是0该像素点就为0：
![](./Images/004.jpg)
### 1、程序分析：
该程序首先是载入和显示一幅图像，然后定义一个Mat类型的变量来获得getStructuringElement函数的返回值。getStructuringElement函数用于指定形状和尺寸。erode函数进行图形的腐蚀操作，imshow函数进行显示，而waitKey函数用于等待按键按下让窗口显示。
### 2、主要函数说明：
erode()函数可以对输入图像用特定结构元素进行腐蚀操作，该结构元素确定腐蚀操作过程中的邻域的形状，各点像素值将被替换为对应邻域上的最小值：

![](./Images/02.png)

erode（InputArray src，OutputArraydst，InputArray kernel，Point anchor，int iterations，int borderType，constScalar& borderValue)

（1）第一个参数，InputArray 类型的 src，输入图像，即源图像，填 Mat 类的对象即可。图像通道的数量可以是任意的，但图像深度应为 CV_8U，CV_16U，CV_16S，CV_32F 或 CV_64F 其中之一。

（2）第二个参数，OutputArray 类型的 dst，即目标图像，需要和源图片有一样的尺寸和类型。

（3）第三个参数，InputArray 类型的 kernel，腐蚀操作的内核。若为 NULL 时，表示的是使用参考点位于中心 3x3 的核。我们一般使用函数 getStructuringElement 配合这个参数的使用。getStructuringElement 函数会返回指定形状和尺寸的结构元素（内
核矩阵）。

（4）第四个参数，Point 类型的 anchor，锚的位置，其有默认值（-1，-1），表示锚位于单位（element）的中心，我们一般不用管它。

（5）第五个参数，int 类型的 iterations，迭代使用 erode（）函数的次数，默认值为 1。

（6）第六个参数，int 类型的 borderType，用于推断图像外部像素的某种边界模式。注意它有默认值 BORDER_DEFAULT。

（7）第七个参数，const Scalar&类型的 borderValue，当边界为常数时的边界值，有默值 morphologyDefaultBorderValue()，一般我们不用去管他。

### 3、运行的效果图如下：
![](./Images/002.png)

## 三、第三个程序：图像模糊
### 1、程序分析：
图像模糊即用OpenCV对图像进行均值滤波操作，主要使用blur函数。代码的结构是载入和显示原图后调用一次blur函数。
### 2、主要函数说明：
blur函数的作用是对输入的图像src进行均值滤波后用dst输出。格式为：
void blur(InputArray src, OutputArraydst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )；

（1）第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。该函数对通道是独立处理的，且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。

（2）第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。

（3）第三个参数，Size类型（对Size类型稍后有讲解）的ksize，内核的大小。一般这样写Size( w,h )来表示内核的大小( 其中，w 为像素宽度， h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小。

（4）第四个参数，Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。

（5）第五个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT。
   
blur()函数的核如下图所示：

![](./Images/006.png)
### 3、运行的效果图如下：
![](./Images/003.png)
## 四、第四个程序：canny边缘检测
### 1、程序分析
首先载入图像，并将其转成灰度图像，再用blur函数进行图像模糊以降噪，然后用canny函数进行边缘检测，最后显示。
### 2、主要函数说明：
void cvCanny( const CvArr* image, CvArr* edges, double threshold1, double threshold2, int aperture_size=3 );

（1）它的第一个参数表示输入图像，必须为单通道灰度图。

（2）第二个参数表示输出的边缘图像，为单通道黑白图。

（3）第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割即如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个点与高于上限值的像素点连接时我们才保留，否则删除。

（4）第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。
边缘检测的一般步骤
 
1）滤波：边缘检测的算法主要是基于图像强度的一阶和二阶导数，但导数通常对噪声很敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核，然后基于高斯核函数对图像灰度矩阵的每一点进行加权求和。
 
2）增强：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将图像灰度点邻域强度值有显著变化的点凸显出来。在具体编程实现时，可通过计算梯度幅值来确定。
 
3）检测：经过增强的图像，往往邻域中有很多点的梯度值比较大，而在特定的应用中，这些点并不是我们要找的边缘点，所以应该采用某种方法来对这些点进行取舍。实际工程中，常用的方法是通过阈值化方法来检测。
### 3、运行的效果图如下：
![](./Images/005.png)


## 总结
     将自己的环境都配置好了以后，我就用书中的代码做了一些测试，就是上面的四个程序。第一个程序是简单的测试visual studio的OpenCV环境是否配置正确，在测试的过程中，我遇到了一些问题。比如程序未报错，但是它找不到图片。最后通过调试，我明白了程序中图片的位置要使用绝对路径。在vs中要用//表示绝对路径，即Mat srcImage = imread("D://jpg//001.png");最后运行它就能显示一张图片了。第二个程序是模糊处理，主要使用到了erode（）这个函数，它主要是对输入图像用特定结构元素进行腐蚀操作，该结构元素确定腐蚀操作过程中的邻域的形状，各点像素值将被替换为对应邻域上的最小值。最终效果还是非常明显的，我在这个程序中学到了如何使用erode（）函数。在第三个程序中，我学到了blur（）函数的具体用法，它主要是对图像进行均值滤波，从而达到模糊的效果。第四个程序是canny检测，主要是利用canny函数进行检测，它非常复杂，但是它却能达到检测的效果。它的第一个参数表示输入图像，必须为单通道灰度图。第二个参数表示输出的边缘图像，为单通道黑白图。第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割即如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个点与高于上限值的像素点连接时我们才保留，否则删除。第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。这几个参数就能进行图像的边缘检测。

      通过上面的四个程序的测试及运行，我对OpenCV有了一个比较深刻的认识，我认识到它对图像法处理具有强大的功能。OpenCv  全称Open Source Computer Version,它是一个开源的计算机视觉库，可通过处理图像和视频来完成各种任务，包括摄像头输入的信号以及机器人识别现实生活中的物体。它的语法虽然很多，但是我写了这四个程序后，发现与其他语言有相同之处，它有其他语言的接口，所以，我觉得它非常强大，在今后的学习过程中，我要认真学习这门课，掌握它的具体使用方法，提高自己的能力。
  
