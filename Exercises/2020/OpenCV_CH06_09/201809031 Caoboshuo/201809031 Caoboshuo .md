# 第三次作业
## 第6章 图像处理
### 6.1 线性滤波:方框滤波、均值滤波、高斯滤波
### 6.1.1 平滑处理

平滑处理(smoothing)也称模糊处理(bluring)，是一种简单且使用频率很高的图像处理方法。平滑处理的用途有很多，最常见的是用来减少图像上的噪点或者失真。在涉及到降低图像分辨率时，平滑处理是非常好用的方法。

### 6.1.2 图像滤波与滤波器

图像滤波,指在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。

消除图像中的噪声成分叫作图像的平滑化或滤波操作。信号或图像的能量大部分集中在幅度谱的低频和中频段，而在较高频段，有用的信息经常被噪声淹没。因此一个能降低高频成分幅度的滤波器就能够减弱噪声的影响。

图像滤波的目的有两个:一个是抽出对象的特征作为图像识别的特征模式;
另一个是为适应图像处理的要求，消除图像数字化时所混入的噪声。
而对滤波处理的要求也有两条:一是不能损坏图像的轮廓及边缘等重要信息;
二是使图像清晰视觉效果好。
平滑滤波是低频增强的空间域滤波技术。它的目的有两类:一类是模糊:另
一类是消除噪音。

### 6.1.3 线性滤波器的简介

线性滤波器:线性滤波器经常用于剔除输入信号中不想要的频率或者从许多频率中选择一个想要的频率。

### 6.1.4 滤波和模糊

上文已经提到过，滤波是将信号中特定波段频率滤除的操作，是抑制和防止干扰的一项重要措施。

### 6.1.5 邻域算子与线性邻域滤波

邻域算子(局部算子)是利用给定像素周围的像素值的决定此像素的最终输出值的一种算子。而线性邻域滤波就是一种常用的邻域算子，像素的输出值取决于输入像素的加权和。

邻域算子除了用于局部色调调整以外，还可以用于图像滤波，以实现图像的平滑和锐化，图像边缘增强或者图像噪声的去除。本节我们介绍的主角是线性邻域滤波算子，即用不同的权重去结合一个小邻域内的像素，来得到应有的处理效果。

### 6.1.6 方框滤波 ( box Filter )

方框滤波(box Filter)被封装在一一个 名为boxblur的函数中，即boxblur函数
的作用是使用方框滤波器(box filter)来模糊-张图片， 从src输入，从dst输出。

### 6.1.7 均值滤波

均值滤波，是最简单的一种滤波操作， 输出图像的每-一个像 素是核窗口内输入图像对应像素的平均值(所有像素加权系数相等),其实说白了它就是归一化后.的方框滤波。我们在下文进行源码剖析时会发现，blur 丽数内部中其实就是调用了一下boxFilter。

### 6.1.8 高斯滤波

1.高斯滤波的理论简析

高斯滤波是一种线性平滑滤波，可以消除高斯噪声，广泛应用于图像处理的减噪过程。通俗地讲，高斯滤波就是对整幅图像进行加权平均的过程，每一一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是:用一个模板(或称卷积、掩模)扫描图像中的每-一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。

2.高斯滤波: GaussianBlur函数

GaussianBlur函数的作用是用高斯滤波器来模糊- -张图片， 对输入的图像sre进行高斯滤波后用dst 输出。它将源图像和指定的高斯核函数做卷积运算，并且支持就地过滤(In-placefi1tering)。

### 6.1.11 线性滤波核心API函数

1.方框滤波：

boxFilter的函数作用是使用方框滤波(box filter)来模糊- -张图片，由src输入，dst输出。

运行代码：
​``` 
#include "opencv2/core/core.hpp"
#include"opencv2/highgui/highgui.hpp"
#include"opencv2/imgproc/imgproc.hpp"
int main()
{
//载入原图
Mat image= imread ("2.jpg");
//创建窗口
namedWindow("方框滤波[原图]”);
namedWindow ("方框滤波[效果图] ");
//显示原图.
imshow("方框滤波[原图] "，image );
//进行滤波操作
Mat out;
boxFilter (image, out, -1,Size(5，5));
//显示效果图
imshow ("方框滤波[效果图]”,out );
waitKey(0 ) ;
}


​```

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/174cdfa3c1830f34156cd1c9be86f9c711d63b90.png@518w.png)

2.均值滤波：

blur的作用是对输入的图像src进行均值滤波后用dst输出。

![markdown](https://i0.hdslb.com/bfs/album/5f661452bf41506f86df5aeb2453fc910558292f.png@518w.png)

3.高斯滤波:

GaussianBlur函数的作用是用高斯滤波器来模糊一张图片， 对输入的图像src进行高斯滤波后用dst输出。

![markdown](https://i0.hdslb.com/bfs/album/a2e5e8823a923c25710b77e8dbce8ec129a65d7d.png@518w.png)

### 6.2 非线性滤波：中值滤波、双边滤波

### 6.2.1 非线性滤波概述

我们所考虑的滤波器都是线性的，即两个信号之和的响应和它们各自响应之和相等。换句话说，每个像素的输出值是一些输 入像素的加权和。线性滤波器易于构造，并且易于从频率响应角度来进行分析。

然而，在很多情况下，使用邻域像素的非线性滤波会得到更好的效果。比如在噪声是散粒噪声而不是高斯噪声，即图像偶尔会出现很大的值的时候，用高斯滤波器对图像进行模糊的话，噪声像素是不会被去除的，它们只是转换为更为柔和但仍然可见的散粒。这就到了中值滤波登场的时候了。

### 6.2.2中值滤波

中值滤波(Median filter)是一种典型的非线性滤波技术，基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的边缘细节。

中值滤波在一定的条件下可以克服常见线性滤波器，如最小均方滤波、方框滤波器、均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息。保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。

### 6.2.3双边滤波

双边滤波(Bilateral filter) 是一种非线性的滤波方法，是结合图像的空间邻
近度和像素值相似度的一种折中处理，同时考虑空域信息和灰度相似性，达到保
边去噪的目的，具有简单、非迭代、局部的特点。

### 6.2.4 非线性滤波相关核心API函数
1.中值滤波: medianBlur函数

medianBlur函数使用中值滤波器来平滑(模糊)处理- -张图片，从sre输入，
结果从dst输出。对于多通道图片，它对每一个通道都单独进行处理，并且支持
就地操作(In-placeoperation)。

运行结果如下：


2.双边滤波：bilateralFilter函数

此函数的作用是用双边滤波器来模糊处理一张图片，由sre输入图片，结果于dst输出。函数原型如下。

运行结果如下：


### 6.3形态学滤波 (1 ):腐蚀与膨胀

### 6.3.1 形态学概述

形态学(morphology)一词通常表示生物学的一个分支，该分支主要研究动
植物的形态和结构。而我们图像处理中的形态学，往往指的是数学形态学。下面
一起来了解数学形态学的概念。

数学形态学(Mathematical morphology) 是- -门建立在格论和拓扑学基础之
上的图像分析学科，是数学形态学图像处理的基本理论。其基本的运算包括:二
值腐蚀和膨胀、二值开闭运算、骨架抽取、极限腐蚀、击中击不中变换、形态学
梯度、Top-hat 变换、颗粒分析、流域变换、灰值腐蚀和膨胀、灰值开闭运算、灰
值形态学梯度等。

### 6.3.2 膨胀

膨胀(dilate) 就是求局部最大值的操作。从数学角度来说，膨胀或者腐蚀操作就是将图像(或图像的一部分区域，称之为A)与核(称之为B)进行卷积。

核可以是任何形状和大小，它拥有一个单独定义出来的参考点，我们称其为锚(anchorpoint)。 多数情况下，核是一个小的，中间带有参考点和实心正方形或者圆盘。其实，可以把核视为模板或者掩码。

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/15ba0ceceb1713e8033f7049d9f4ce802fce631d.jpg@518w.jpg)

### 6.3.3腐蚀

大家应该知道，膨胀和腐蚀(erode) 是相反的一对操作， 所以腐蚀就是求局
部最小值的操作。

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/32b2be6cc0d751411d741137d7a8ac6989d7bbb5.jpg@518w.jpg)

### 6.4 形态学滤波(2):开运算、闭运算、形态学梯度、顶帽、黑帽

### 6.4.1 开运算

开运算(Opening Operation)，其实就是先腐蚀后膨胀的过程。

### 6.4.2 闭运算

先膨胀后腐蚀的过程称为闭运算(Closing Operation)

### 6.4.3 形态学梯度

形态学梯度(Morphological Gradient) 是膨胀图与腐蚀图之差

### 6.4.4顶帽

顶帽运算(Top Hat)又常常被译为”礼帽“运算，是原图像与上文刚刚介绍
的“开运算"的结果图之差:

### 6.4.5 黑帽

黑帽(BlackHat)运算是闭运算的结果图与原图像之差。

### 6.4.7核心API函数: morphologyEx()

上面已经讲到，morphologyEx 雨数利用基本的膨胀和腐蚀技术，来执行更加
高级形态学变换，如开闭运算、形态学梯度、“顶帽”、“黑帽”等。

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/8d02a6931cd01703768edf6a24db348863b736cb.jpg@518w.jpg)


### 6.5 漫水填充

本节我们将一起探讨OpenCV填充算法中漫水填充算法相关的知识点，并了
解OpenCV中实现漫水填充算法的两个版本的floodFill 函数的使用方法。

### 6.5.1 漫水填充的定义

漫水填充法是一种用特定的颜色填充连通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分，以便对其进行进一步 处理或分析，也可以用来从输入图像获取掩码区域，掩码会加速处理过程，或只处理掩码指定的像素点，操作的结果总是某个连续的区域。

### 6.5.3 实现漫水填充算法: floodFill 函数

在OpenCV中，漫水填充算法由floodFill函数实现，其作用是用我们指定的颜色从种子点开始填充一个连接域。连通性由像素值的接近程度来衡量。

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/a7a4dbb7ae7ae6f21faed0e22b675cb1f7d18cda.png@518w.png)

### 6.6 图像金字塔与图片尺寸缩放

本节中探讨图像金字塔的一些基本概念,学习如何使用OpenCV函数pyrUp和pyrDown对图像进行向上和向下采样，以及了解专门用于缩放图像尺寸的resize函数的用法。

### 6.6.1 引言

我们经常会将某种尺寸的图像转换为其他尺寸的图像，如果要放大或者缩小图片的尺寸，笼统来说，可以使用OpenCV提供的如下两种方法。

●resize 函数。这是最直接的方式
●pyrUp0、pyrDown()函数。即图像金字塔相关的两个函数，对图像进行向上采样和向下采样的操作。

### 6.6.2关于图像金字塔

图像金字塔是图像中多尺度表达的一种，最主要用于图像的分割，是一种以多分辨率来解释图像的有效但概念简单的结构。

图像金字塔最初用于机器视觉和图像压缩，一-幅图像的金字塔是一系列以金字塔形状排列的，分辨率逐步降低且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。

### 6.6.3高斯金字塔

高斯金字塔是通过高斯平滑和亚采样获得一些列下采样图像，也就是说第K 层高斯金字塔通过平滑、亚采样就可以获得K+1层高斯图像。高斯金字塔包含了一系列低通滤波器，其截止频率从上一.层到下一层以因子2逐渐增加，所以高斯金字塔可以跨越很大的频率范围。

### 6.6.4拉普拉斯金字塔

拉普拉斯金字塔是通过源图像减去先缩小后再放大的图像的一系列图像构成的。

### 6.6.5 尺寸调整: resize0函数

此函数将源图像精确地转换为指定尺寸的目标图像。如果源图像中设置了ROI (Region Of Interest，感兴趣区域)，那么resize()函数会对源图像的ROI区域进行调整图像尺寸的操作,来输出到目标图像中。若目标图像中已经设置了ROI区域，不难理解resize()将会对源图像进行尺寸调整并填充到目标图像的ROI中。

### 6.6.6 图像金字塔相关 API函数

图像金字塔相关API函数主要是pyrUp、pyrDown这一对， 下 面分别对其进
行讲解。

1.向上采样: pyrUp()函数

pyrUp)函数的作用是向上采样并模糊- -张图像， 说白了就是放大一张图片。

2.采样: pyrDown()函数

pyrDown)函数的作用是向下采样并模糊- -张图片，说白了就是缩小一张图片。

### 6.7 阈值化

在对各种图形进行处理操作的过程中，我们常常需要对图像中的像素做出取舍与决策，直接剔除一些低于或者高于一定值的像素。

阈值可以被视作最简单的图像分割方法。比如，从一-副图像中利用阈值分割出我们需要的物体部分(当然这里的物体可以是一部分或者整体)。这样的图像分割方法基于图像中物体与背景之间的灰度差异，而且此分割属于像素级的分割。

为了从一副图像中提取出我们需要的部分，应该用图像中的每一个像素点的灰度值与选取的阈值进行比较，并作出相应的判断。注意:阈值的选取依赖于具体的问题。即物体在不同的图像中有可能会有不同的灰度值。

### 6.7.1 固定阈值操作: Threshold0函数\

函数Threshold()对单通道数组应用固定阈值操作。该函数的典型应用是对灰
度图像进行阈值操作得到二值图像，(compare()函数 也可以达到此目的)或者是
去掉噪声，例如过滤很小或很大象素值的图像点。

### 6.7.2 自适应阈值操作: adaptiveThreshold0函数

adaptiveThresholdO函数的作用是对矩阵采用自适应阈值操作，支持就地操
作。

### 6.8 本章小结

本章中我们学习了各种利用OpenCV进行图像处理的方法。包括属于线性滤波的方框滤波、均值滤波与高斯滤波，属于非线性滤波的中值滤波、双边滤波;两种基本形态学操作一膨胀 与腐蚀; 5种高级形态学滤波操作一开运算、 闭运算、形态学梯度、顶帽以及黑帽;还有漫水填充算法、图像金字塔、图像缩放、阈值化。涉及到的内容可谓非常丰富。相信学完此章的内容，你对OpenCV的了解已经.上了一个层次。

## 第7章 图像变换

### 7.1 基于OpenCV的边缘检测

1. [第一步]滤波

2. [第二步]增强

3. [第三步]检测

### 7.1.2 canny算子

1. canny算子简介

Canny边缘检测算子是John F.Canny 于1986 年开发出来的-一个多级边缘检
测算法。更为重要的是，Canny 创立了边缘检测计算理论(Computational theory
ofedge detection)， 解释了这项技术是如何工作的。Canny边缘检测算法以Canny
的名字命名，被很多人推崇为当今最优的边缘检测的算法。

2. Canny边缘检测的步骤

(1) [第一步]消除噪声

(2) [第二步]计算梯度幅值和方向

3. Canny 边缘检测: Canny()函数

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/d7f3c556a6f5aad044007215f505b589bbeaf635.png@518w.png)

### 7.1.3 sobel 算子

1. sobel算子的基本概念

Sobel算子是一个主要用于边缘检测的离散微分算子(discrete differentiation
operator)。它结合了高斯平滑和微分求导，用来计算图像灰度函数的近似梯度。
在图像的任何一点 使用此算子，都将会产生对应的梯度矢量或是其法矢量。

2.sobel算子的计算过程

(1)分别在x和y两个方向求导。
(2)在图像的每一一点， 结合以上两个结果求出近似梯度:

运行结果如下：
![markdown](https://i0.hdslb.com/bfs/album/8e31ad45051ce5a007b171e5b3b2534de7249bd4.png@518w.png)

3.使用Sobel算子: Sobel()函数

Sobel函数使用扩展的Sobel算子，来计算- -阶、 二阶、三阶或混合图像差分。

### 7.1.4 Laplacian 算子
1. Laplacian 算子简介
Laplacian算子是n维欧几里德空间中的一一个二阶微分算子，定义为梯度grad
的散度div。

运行结果如下：

![markdown](https://i0.hdslb.com/bfs/album/555f56cb2919cb6e37d97698a366ec3c8764508f.png@518w.png)

### 7.1.5 scharr 滤波器

我们一般直接称scharr为滤波器，而不是算子。上文已经讲到，它在OpenCV
中主要是配合Sobel算子的运算而存在的。

### 7.2 霍夫变换

本节中，我们将一起探讨OpenCV中霍夫变换相关的知识点，并了解了OpenCV中实现霍夫线变换的HoughLines、 HoughLinesP 函数的使用方法，以及实现霍夫圆变换HoughCirecles 丽数的使用方法。

### 7.2.1 霍夫变换概述

霍夫变换(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。

### 7.2.2 OpenCV 中的霍夫线变换

我们知道，霍夫线变换是- -种用来寻找直线的方法.在使用霍夫线变换之前，首先要对图像进行边缘检测的处理，即霍夫线变换的直接输入只能是边缘二值图像。

OpenCV支持三种不同的霍夫线变换，它们分别是:标准霍夫变换( Standard Hough Transform, SHT)、多尺度霍夫变换( Multi- Scale Hough Transform, MSHT)和累计概率霍夫变换( Progressive Probabilistic Hough Transform, PPHT)。

### 7.2.3 霍夫线变换的原理

(1)众所周知，一条直线在图像二维空间可由两个变量表示，有以下两种情
况。

①在笛卡尔坐标系:可由参数斜率和截距(m,b) 表示。
②在极坐标系:可由参数极径和极角(r, O)表示。

### 7.2.4 标准霍夫变换: HoughLines())函数

此函数可以找出采用标准霍夫变换的二值图像线条。在OpenCV中，我们可
以用其来调用标准霍夫变换SHT和多尺度霍夫变换MSHT的OpenCV内建算法。

### 7.2.5累计概率霍夫变换: HoughLinesP()函数

此函数在HoughLines的基础上，在末尾加了一个代表Probabilistic (概率)
的P，表明它可以采用累计概率霍夫变换(PPHT) 来找出二值图像中的直线。

### 7.2.6霍夫圆变换

霍夫圆变换的基本原理和上面讲的霍夫线变化大体上是很类似的，只是点对
应的二维极径极角空间被三维的圆心点x、y和半径r空间取代。说“大体上类似”
的原因是，如果完全用相同的方法的话，累加平面会被三维的累加容器所代替一
在这三维中，一维是x，一维是y，另外一维是圆的半径r。这就意味着需要大
量的内存而且执行效率会很低，速度会很慢。

### 7.2.7霍夫梯度法的原理

霍夫梯度法的原理是这样的:
(1)首先对图像应用边缘检测，比如用canny边缘检测。
(2)然后，对边缘图像中的每一一个非零点， 考虑其局部梯度，即用Sobel()函
数计算x和y方向的Sobel--阶导数得到梯度。
(3)利用得到的梯度，由斜率指定的直线上的每-个点都在累加器中被累加，
这里的斜率是从一个指定的最小值到指定的最大值的距离。
(4)同时，标记边缘图像中每一一个非 0像素的位置。
(5)然后从二维累加器中这些点中选择候选的中心，这些中心都大于给定阈
值并且大于其所有近邻。这些候选的中心按照累加值降序排列，以便于最支持像
素的中心首先出现。
(6)接下来对每一-个中心，考虑所有的非0像素。
(7)这些像素按照其与中心的距离排序。从到最大半径的最小距离算起，选
择非0像素最支持的一条 半径。
(8)如果一个中心收到边缘图像非0像素最充分的支持，并且到前期被选择
的中心有足够的距离，那么它就会被保留下来。

这个实现可以使算法执行起来更高效，或许更加重要的是，能够帮助解决三
维累加器中会产生许多噪声并且使得结果不稳定的稀疏分布问题。

人无完人，金无足赤。同样，这个算法也并不是十全十美的，还有许多需要
指出的缺点。

### 7.2.8 霍夫梯度法的缺点

(1)在霍夫梯度法中，我们使用Sobel 导数来计算局部梯度，那么随之而来
的假设是，它可以视作等同于一条局部切线，这并不是一个数值稳定的做法。在
大多数情况下，这样做会得到正确的结果，但或许会在输出中产生一些噪声。

(2)在边缘图像中的整个非0像素集被看做每个中心的候选部分。因此，如
果把累加器的阈值设置偏低，算法将要消耗比较长的时间。此外，因为每-一个中
心只选择-一个圆，如果有同心圆，就只能选择其中的-一个。

(3)因为中心是按照其关联的累加器值的升序排列的，并且如果新的中心过
于接近之前已经接受的中心的话，就不会被保留下来。且当有许多同心圆或者是
近似的同心圆时，霍夫梯度法的倾向是保留最大的一个圆。可以说这是一种比较
极端的做法，因为在这里默认Sobel导数会产生噪声，若是对于无穷分辨率的平
滑图像而言的话，这才是必须的。

### 7.2.9霍夫圆变换: HoughCircles()函数

HoughCircles函数可以利用霍夫变换算法检测出灰度图中的圆。它相比之前
的HoughLines和HoughLinesP，比较明显的一- 个区别是不需要源图是二值的，而
HoughLines和HoughLinesP都需要源图为二值图像。

### 7.3 重映射

本节中，我们主要一起了解重映射的概念，以及OpenCV中相关的实现函数 remap()。

### 7.3.1重映射的概念

重映射，就是把--幅图像中某位置的像素放置到另一个图片指定位置的过程。
为了完成映射过程，需要获得一些插值为非整数像素的坐标，因为源图像与目标
图像的像素坐标不是- --对应的。 一 般情况下，我们通过重映射来表达每个像素
的位置(x,y)， 像这样:

### 7.3.2实现重映射: remap0函数

remap0函数会根据指定的映射形式，将源图像进行重映射几何变换.

### 7.4 仿射变换.

本节中，我们将一起了解仿射变换的概念，以及OpenCV中相关的实现函数
warpAffine和getRotationMatrix2D.

### 7.4.1认识仿射变换

仿射变换(Affine Transformation或Affine Map)，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接 上-一个平移，变换为另一个向量空间的过程。它保持了二维图形的“平直性”(直线经过变换之后依然是直线)和“平行性”(二维图形之间的相对位置关系保持不变，平行线依然是平行线，且直线上点的位置顺序不变)。

### 7.4.2仿射变换的求法

我们知道，仿射变换表示的就是两幅图片之间的一种联系， 关于这种联系的
信息大致可从以下两种场景获得。

### 7.4.3进行仿射变换: warpAffine()函数

warpffine函数的作用是依据以下公式子，对图像做仿射变换。

### 7.4.4计算c维旋转变换知矩阵: getRotationMatrix2D0函数

getRotationMatrix2D0函数用于计算 二维旋转变换矩阵。变换会将旋转中心映射
到它自身。

## 第8章 图像轮廓与图像分割修复

### 8.1查找并绘制轮廓

一个轮廓一般对应一系列的点，也就是图像中的一条曲线。其表示方法可能.根据不同的情况而有所不同。在OpenCV中，可以用findContours()函数从二值图像中查找轮廓

### 8.1.2 绘制轮廓: drawContours(函数

drawContours()函数用于在图像中绘制外部或内部轮廓。

### 8.1.3基础示例程序: 轮廓查找


### 8.1.4 综合示例程序:查找并绘制轮廓

### 8.2 寻找物体的凸包
### 8.2.1 凸包

凸包(Convex Hull)是一-个计算几何(图形学)中常见的概念。简单来说，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它是能包含点集中所有点的。理解物体形状或轮廓的一种比较有用的方法便是计算.个物体的凸包，然后计算其凸缺陷(convexity defects)。很多复杂物体的特性能很好地被这种缺陷表现出来。

### 8.2.2寻找凸包: convexHull()函数

convexHul()函数用于寻找图像点集中的凸包，其原型声明如下。

### 8.2.3基础示例程序: 凸包检测基础

为了理解凸包检测的运用方法，下面放出一个完整的示例程序。程序中会首
先随机生成3~103个坐标值随机的彩色点，然后利用convexHull, 对由这些点链
接起来的图形求凸包。

### 8.3使用多边形将轮廓包围

在实际应用中，常常会有将检测到的轮廓用多边形表示出来的需求。本节就
为大家讲解如何用多边形来表示出轮廓，或者说如何根据轮廓提取出多边形。先
让我们一-起学 习用OpenCV创建包围轮廓的多边形边界时会接触到的一些函 数。

### 8.3.1 返回外部矩形边界: boundingRect()函数

此函数计算并返回指定点集最外面(up-right)的矩形边界。

### 8.3.2寻找最小包围矩形 : minAreaRect()函数

此函数用于对给定的2D点集，寻找可旋转的最小面积的包围矩形。

### 8.3.3寻找最小包围圆形: minEnclosingCircle0()函数

minEnclosingCircle函数的功能是利用一种迭代算法，对给定的2D点集，去
寻找面积最小的可包围它们的圆形。

### 8.3.4 用椭圆拟合二维点集: fitEllipse()函数

此函数的作用是用椭圆拟合二维点集。

### 8.3.5 逼近多边形曲线: approxPolyDP0函数

approxPolyDP函数的作用是用指定精度逼近多边形曲线。

### 8.3.6 基础示例程序: 创建包围轮廓的矩形边界

此示例程序以minAreaRect函数为核心，先随机生成3~103个彩色点，然后
绘制一个可以旋转的最小的矩形，将这些点全部包含进去。操作依然是通过键盘
按下任意键来重新生成随机点，并寻找最小面积的包围矩形。

### 8.3.8 综合示例程序:使用多边形包围轮廓

经过上述两个基础示例程序的学习，相信大家应该对minAreaRect 和minEnclosingCircle函数的用法有了一定的认识。这两个示例程序中，处理的轮廓都是程序自己随机生成的点。在接下来这个综合一点的示例程序中，让我们载入一幅图像，用上文中学到的函数来创建包围轮廓的矩形和圆形边界框。

## 8.4 图像的矩

矩函数在图像分析中有着广泛的应用，如模式识别、目标分类、目标识别与方位估计、图像编码与重构等。一个从一幅数字图形中计算出来的矩集，通常描述了该图像形状的全局特征，并提供了大量的关于该图像不同类型的几何特性信息，比如大小、位置、方向及形状等。图像矩的这种特性描述能力被广泛地应用在各种图像处理、计算机视觉和机器人技术领域的目标识别与方位估计中。一阶矩与形状有关，二阶矩显示曲线围绕直线平均值的扩展程度，三阶矩则是关于平均值的对称性的测量。由二阶矩和三阶矩可以导出一组共7个不变矩。而不变矩是图像的统计特性，满足平移、伸缩、旋转均不变的不变性，在图像识别领域得到了广泛的应用。

### 8.4.3 计算轮廓长度: arcLength0函数

arcLength()函数用于计算封闭轮廓的周长或曲线的长度。

### 8.5 分水岭算法

在许多实际运用中，我们需要分割图像，但无法从背景图像中获得有用信息。分水岭算法( watershed algorithm) 在这方面往往是非常有效的。此算法可以将图像中的边缘转化成“山脉”，将均匀区域转化为“山谷”，这样有助于分割目标。

分水岭算法，是一种基于拓扑理论的数学形态学的分割方法，其基本思想.是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。分水岭的概念和形成可以通过模拟浸入过程来说明:在每-一个局部极小值表面，刺穿一个小孔，然后把整个模型慢慢浸入水中，随着浸入的加深，每一个局部极小值的影响域慢慢向外扩展，在两个集水盆汇合处构筑大坝，即形成分水岭。

### 8.5.1实现分水岭算法: watershed0函数

函数watershed实现的分水岭算法是基于标记的分割算法中的一种。在把图像传给函数之前，我们需要大致勾画标记出图像中的期望进行分割的区域，它们被标记为正指数。所以，每一个区域都会被标记为像素值1、2、3等，表示成为一个或者多个连接组件。这些标记的值可以使用findContours(函数和drawContours()函数由二进制的掩码检索出来。不难理解，这些标记就是即将绘制出来的分割区域的“种子”，而没有标记清楚的区域，被置为0。在函数输出中，每一个标记中的像素被设置为“种子”的值，而区域间的值被设置为-1。

### 8.6.1实现图像修补: inpaint()函数

在新版OpenCV中，图像修补技术由inpaint函数实现，它可以用来从扫描的
照片中清除灰尘和划痕，或者从静态图像或视频中去除不需要的物体。其原型声
明如下。

### 8.7 本章小结
本章中，我们先学习了查找轮并绘制轮廓，然后学习了如何寻找到物体的凸
包，接着是使用多边形来包围轮廓，以及计算一个图像的矩。在本章后面几节，
还学习了分水岭算法和图像修补操作的实现方法。

## 第9章 直方图与匹配

### 9.1 图像直方图概述

直方图广泛运用于很多计算机视觉运用当中，通过标记帧与帧之间显著的边缘和颜色的统计变化，来检测视频中场景的变化。在每个兴趣点设置一个 有相近特征的直方图所构成“标签”，用以确定图像中的兴趣点。边缘、色彩、角度等直.方图构成了可以被传递给目标识别分类器的一个通用特征类型。色彩和边缘的直方图序列还可以用来识别网络视频是否被复制。

其实，简单点说，直方图就是对数据进行统计的-一种方法，并且将统计值组织到一系列事先定义好的bin当中。其中，bin 为直方图中经常用到的-一个概念，可翻译为“直条”或“组距”，其数值是从数据中计算出的特征统计量，这些数据可以是诸如梯度、方向、色彩或任何其他特征。且无论如何，直方图获得的是数据分布的统计图。通常直方图的维数要低于原始数据。总而言之，直方图是计算机视觉中最经典的工具之一。

### 9.2 直方图的计算与绘制

直方图的计算在OpenCV中可以使用calcHist()函数，而计算完成之后，可以采用OpenCV中的绘图函数，如绘制矩形的rectangle()函数，绘制线段的line()来完成。

9.2.1 计算直方图: calcHist()函数

在OpenCV中，calcHist()函数用于计算一个或者多个阵列的直方图。原型如下。

### 9.2.2 找寻最值: minMaxLoc()函数

minMaxLoc()函数的作用是在数组中找到全局最小值和最大值。它有两个版本的原型，在此介绍常用的那一个版本。

### 9.2.4 示例程序: 计算并绘制图像一维直方图

上文中已经讲解了calcHist)函数的用法，并绘制出了图像的H-S二维直方图。而本节我们会通过一个示例，来学习图像一维直方图的计算和绘制过程。

### 9.2.5示例程序: 绘制RGB三色直方图

上文我们讲解的是单个分量的一维直方图的绘制，接下来看看如何分别绘制图像的RGB三色直方图。

### 9.3 直方图对比

对于直方图来说，一个不可或缺的工具便是用某些具体的标准来比较两个直方图的相似度。要对两个直方图(比如说H和H2)进行比较，首先必须选择一个衡量直方图相似度的对比标准(d(H,H2))。 在OpenCV 2.X中，我们用compareHist()函数来对比两个直方图的相似度，而此函数的返回值就是d(H1,H2)。

### 9.3.1对比直方图: compareHist()函数

compareHist()函数用于对两幅直方图进行比较。有两个版本的C++原型，如
下。

### 9.3.2示例程序: 直方图对比

此次的示例程序为大家演示了如何用compareHistQ)函数进行直方图对比。代码中的MatND类是用于存储直方图的一-种 数据结构，用法简单，在这里就不多做讲解，大家看到详细注释的示例程序就会明白。

### 9.4 反向投影
### 9.4.1 引言

如果一幅图像的区域中显示的是一种结构纹理或者一个独特的物体，那么这个区域的直方图可以看作一个概率函数，其表现形式是某个像素属于该纹理或物体的概率。

而反向投影(back projection)就是-种记录给定图像中的像素点如何适应直方图模型像素分布方式的一种方法。

简单的讲，所谓反向投影就是首先计算某一特征的直方图模型，然后使用模型去寻找图像中存在的该特征的方法。

### 9.4.3 反向投影的作用

反向投影用于在输入图像(通常较大)中查找与特定图像(通常较小或者仅1个像素，以下将其称为模板图像)最匹配的点或者区域，也就是定位模板图像出现在输入图像的位置。

### 9.4.4 反向投影的结果

反向投影的结果包含了以每个输入图像像素点为起点的直方图对比结果。可以把它看成是一一个二维的浮点型数组、二维矩阵，或者单通道的浮点型图像。

### 9.4.5 计算反向投影: calcBackProject())函数

calcBackProject()函数用于计算直方图的反向投影。

### 9.4.6 通道复制: mixChannels()函数

此函数由输入参数复制某通道到输出参数特定的通道中。

### 9.5 模板匹配
### 9.5.1 模板匹配的概念与原理

模板匹配是一项在一幅图像中寻找与另一幅模板图像最匹配(相似)部分的技术。在OpenCV2和OpenCV3中，模板匹配由MatchTemplate(函数完成。需要注意，模板匹配不是基于直方图的，而是通过在输入图像上滑动图像块，对实际的图像块和输入图像进行匹配的一种匹配方法。

### 9.5.2 实现模板匹配: matchTemplate()函数

matchTemplate()用于匹配出和模板重叠的图像区域。

### 9.6 本章小结

本章我们学习了广泛运用于很多计算机视觉运用当中的直方图，而简单点说，直方图就是对数据进行统计的一种方法。然后还讲到了反向投影和模板匹配。所谓反向投影就是首先计算某一特征的直方图模型，最后使用模型去寻找图像中存在的该特征的方法。而模板匹配是一项在一幅图像中寻找与另一幅模板图像最匹配(相似)部分的技术。
